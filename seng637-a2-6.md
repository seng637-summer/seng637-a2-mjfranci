**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group: 6      |
|-----------------|
| Francis, Michael                |   
| Le, Michael              |   
| Pretorius, Jean-Charl               |   
| Rainbow, Sam                |
| Sofela, Samuel                |  

# 1 Introduction

This assignment was designed to help us develop an understanding of automated unit testing fundamentals. We familiarize ourselves with the JUnit tool from the XUnit framework, a commonly used unit testing framework in Java. We wrote automated test code using JUnit and created mock objects during test code development.
Before the start of this assignment, our existing knowledge of automated unit testing and black-box testing was limited to the material discussed in lectures so far. We know that JUnit is a unit testing framework for Java that helps for large scale automated testing and is widely used in industry. We also know that Javadoc is a document that contains details of the software to test, and that we should use the Javadoc to gather requirement specifications for generating test suites.
A JUnit test case consists of annotations to control the flow of execution of a unit test and assertions that verify the behavior of the unit being tested. Mocks are fake Java classes that replace external dependencies that should be removed for unit testing and isolating functionalities. Black-box testing is a way JUnit tests plans and cases can be designed when only the requirements are known and the code being tested is unknown. Black-box design techniques include equivalence classes and boundary value testing.
Although these concepts have been learned in class, most of us did not have previous experience with performing automated unit testing with JUnit, using JMock to create and use mock objects, or creating black-box unit tests based on requirements outlined in Javadocs.



# 2 Detailed description of unit test strategy

Different test plans for Range and DataUtilities will be used since these two classes have different functionalities. The first step in designing test plans is to choose an appropriate domain for the input parameters for each class. For the test cases in the Range class, a domain of -100 to 100 will be used because of how comprehensive these range of values are - various positive values, negative values, and a value of zero will be used. For test cases in the DataUtilities classes, jMock will be used to mock the Values2D and KeyedValues classes. The Values2D object will be mocked as a 2-dimensional matrix with 3 rows and 3 columns. Based on these input domain values, separate partitions can be created for equivalence class testing and boundary values can be determined for boundary value testing.

# 3 Test cases developed

Each team member wrote their test cases as described in Tables 1-10.

#### **Table 1.** Range.expandToInclude() Test Cases
| Test Case Name                  | Input Value Partitions                          | Expected Value | Actual Value | Outcome |
|---------------------------------|-------------------------------------------------|----------------|--------------|---------|
|expandToIncludeBelowLowerBound() | Input range:(-100,100); Input value: -100.00001 | 

#### **Table 2.** Range.contains() Test Cases


#### **Table 3.** Range.constrain() Test Cases


#### **Table 4.** Range.intersects() Test Cases


#### **Table 5.** Range.shift() Test Cases


#### **Table 6.** DataUtilities.calculateColumnTotal() Test Cases


#### **Table 7.** DataUtilities.calculateRowTotal() Test Cases


#### **Table 8.** DataUtilities.createNumberArray2D() Test Cases


#### **Table 9.** DataUtilities.getCumulativePercentages() Test Cases


#### **Table 10.** DataUtilities.createNumberArray() Test Cases


# 4 How the team work/effort was divided and managed

For this assignment, our group divided the work so that we each tested one method from each class “Range” and “DataUtilities” of the JFreeChart library. We collected our results and shared them with the rest of the team for review. Table 11 below outlines each team members responsibilities.
#### **Table 11.** Team responsibilities
| Team Member           | Range.class Method to Test                 | DataUtilities.class Method to Test              |
|:---------------------:|:------------------------------------------:|:-----------------------------------------------:|
| Pretorius, Jean-Charl | expandToInclude(Range range, double value) | calculateColumnTotal(Values2D data, int column) |
| Le, Michael           | contains(double value)                     | cacculateRowTotal(Values2D data, int row)       |
| Francis, Michael      | constrain(double value)                    | createNumberArray2D(double[][] data)            |
| Sofela, Samuel        | intersects(double lower, double upper)     | getCumulativePercentages(KeyedValues data)      |
| Rainbow, Sam          | shift(Range base, double delta)            | createNumberArray(double[] data)                |

# 5 Difficulties encountered, challenges overcome, and lessons learned

We encountered a few problems in this lab. Some team members attempted to run the files on IntelliJ and TMC Netbeans at first, but had difficulties getting the files to run. Once the team switched to using Eclipse and followed the instructions on github our code started working.
Reading the included Javadocs was also confusing to understand at first, but our team eventually understood the documentation.
The team learned about how to perform black-box testing by extracting the specifications of the system from the documentation and coming up with appropriate equivalence classes and boundary conditions. Figuring out which equivalence classes and boundaries should be tested and which ones where possible to test was quite challenging. 
Finally, understanding that the DataUtilities methods were defective was difficult to realize at first. Using our human logic, we were able to understand that the DataUtilities methods were not working properly and report the bugs properly.


# 6 Comments/feedback on the lab itself

We all found this assignment to be interesting and informative, and a part of software that none of us had much experience in. Blackbox testing itself has many challenges since the code implementation is hidden and the programmer has very little knowledge of how the methods should operate. Throughout much of our programmuing experience we create the implementation and will go over methods numerous times making changes to them and knowing them intimately. If something in the program breaks we often have a good idea where to start looking.

This lab really forced us to think about how to accurately and extensively test code only knowing how the code should react based on parameters and Javadocs. It allowed us to see how useful JUnit is in creating test suites and how it works by calling @Test, @Before, setUp(), etc. JMock was also used to create mock objects that could be passed as a parameter to a function and confirm method behaviour.
